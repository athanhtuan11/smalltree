{% extends 'base.html' %}
{% block content %}
<!-- Quill CSS -->
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
<style>
    .quill-editor { min-height:180px; }
    @media (max-width: 576px) {
        .quill-editor { min-height:120px; }
    }
</style>
<div class="container-fluid mt-4 mb-4 px-0">
    <h2 class="mb-4 fw-bold" style="color:#43a047;">ƒêƒÉng b√†i vi·∫øt m·ªõi</h2>
    <form method="POST" enctype="multipart/form-data" id="activity-form" onsubmit="return submitQuillContent();">
        <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
        <div class="mb-3">
            <label for="title" class="form-label">Ti√™u ƒë·ªÅ <span class="text-danger">*</span></label>
            <input type="text" class="form-control" id="title" name="title" required placeholder="Nh·∫≠p ti√™u ƒë·ªÅ b√†i vi·∫øt">
        </div>
        <div class="mb-3">
            <label for="content" class="form-label">N·ªôi dung <span class="text-danger">*</span></label>
            <div id="quillEditor" class="quill-editor bg-white"></div>
            <input type="hidden" name="description" id="description">
        </div>
        <div class="mb-3">
            <label for="background" class="form-label">Ch·ªçn h√¨nh n·ªÅn cho b√†i vi·∫øt</label>
            <input type="file" class="form-control" id="background" name="background" accept="image/*">
            <div id="preview-bg" class="mt-3" style="display:none;">
                <img id="preview-img" src="#" alt="Preview" style="max-width:100%; border-radius:16px; filter: blur(4px) brightness(0.8);">
            </div>
        </div>
        <div class="mb-3">
            <label for="class_id" class="form-label">ƒêƒÉng cho l·ªõp</label>
            <select class="form-select" id="class_id" name="class_id">
                <option value="0">T·∫•t c·∫£ kh√°ch v√£ng lai</option>
                {% for c in classes %}
                <option value="{{ c.id }}" {% if form.class_id.data == c.id %}selected{% endif %}>{{ c.name }}</option>
                {% endfor %}
            </select>
        </div>
        <div class="mb-3">
            <label for="date" class="form-label">Ng√†y ƒëƒÉng <span class="text-danger">*</span></label>
            <input type="date" class="form-control" id="date" name="date" required value="{{ form.date.data if form and form.date.data else current_date_iso }}">
        </div>
        <div class="mb-3">
            <label for="images" class="form-label">·∫¢nh ho·∫°t ƒë·ªông (c√≥ th·ªÉ ch·ªçn nhi·ªÅu)</label>
            <input type="file" class="form-control" id="images" name="images" accept="image/*" multiple>
            <div class="form-text text-info">
                <small>üí° <strong>T·ªëi ∆∞u cho 50-100 ·∫£nh:</strong> ·∫¢nh s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông n√©n xu·ªëng ~200KB/·∫£nh tr∆∞·ªõc khi upload.</small>
            </div>
            <div id="compress-progress" class="mt-2" style="display:none;">
                <div class="progress mb-2">
                    <div class="progress-bar bg-info" role="progressbar" style="width: 0%" id="compress-bar"></div>
                </div>
                <small class="text-muted">ƒêang n√©n ·∫£nh: <span id="compress-text">0/0</span></small>
            </div>
            <div id="upload-progress" class="mt-2" style="display:none;">
                <div class="progress">
                    <div class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                </div>
                <small class="text-muted mt-1 d-block">ƒêang upload: <span id="progress-text">0/0</span></small>
            </div>
        </div>
        <button type="submit" class="btn btn-success" id="submit-btn">
            <span class="spinner-border spinner-border-sm d-none" role="status"></span>
            ƒêƒÉng b√†i
        </button>
        <a href="/activities" class="btn btn-outline-secondary ms-2">Quay l·∫°i</a>
    </form>
</div>
<!-- Quill JS -->
<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
<script>
var quill = new Quill('#quillEditor', {
    theme: 'snow',
    placeholder: 'Nh·∫≠p n·ªôi dung b√†i vi·∫øt...',
    modules: {
        toolbar: [
            [{ header: [1, 2, false] }],
            ['bold', 'italic', 'underline', 'strike'],
            [{ 'color': [] }, { 'background': [] }],
            [{ list: 'ordered'}, { list: 'bullet' }],
            ['link', 'image'],
            ['clean']
        ]
    }
});
function submitQuillContent() {
    document.getElementById('description').value = quill.root.innerHTML;
    
    // Ki·ªÉm tra n·∫øu c√≥ ·∫£nh ƒë∆∞·ª£c ch·ªçn
    const fileInput = document.getElementById('images');
    const files = Array.from(fileInput.files);
    
    // Debug: In ra s·ªë l∆∞·ª£ng ·∫£nh
    console.log('S·ªë ·∫£nh ƒë∆∞·ª£c ch·ªçn:', files.length);
    
    // T·ª± ƒë·ªông ch·ªçn ph∆∞∆°ng ph√°p t·ªëi ∆∞u d·ª±a tr√™n s·ªë ·∫£nh
    if (files.length >= 30) {
        console.log('Nhi·ªÅu ·∫£nh (>=30), s·ª≠ d·ª•ng client-side compression cho', files.length, '·∫£nh');
        compressAndUploadImages(files);
        return false; // NgƒÉn submit form, x·ª≠ l√Ω ri√™ng
    } else {
        console.log('√çt ·∫£nh (<30), s·ª≠ d·ª•ng upload truy·ªÅn th·ªëng cho', files.length, '·∫£nh');
        return true; // Submit form b√¨nh th∆∞·ªùng
    }
}

// H√†m n√©n ·∫£nh client-side - T·ªëi ∆∞u cho 60-70 ·∫£nh
function compressImage(file, maxWidth = 800, maxHeight = 600, quality = 0.6) {
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const img = new Image();
        
        img.onload = function() {
            // T√≠nh to√°n k√≠ch th∆∞·ªõc m·ªõi gi·ªØ t·ª∑ l·ªá
            let { width, height } = img;
            if (width > height) {
                if (width > maxWidth) {
                    height = height * (maxWidth / width);
                    width = maxWidth;
                }
            } else {
                if (height > maxHeight) {
                    width = width * (maxHeight / height);
                    height = maxHeight;
                }
            }
            
            canvas.width = width;
            canvas.height = height;
            
            // V·∫Ω v√† n√©n ·∫£nh
            ctx.drawImage(img, 0, 0, width, height);
            canvas.toBlob(resolve, 'image/jpeg', quality);
        };
        
        img.src = URL.createObjectURL(file);
    });
}

// N√©n v√† upload batch
async function compressAndUploadImages(files) {
    const submitBtn = document.getElementById('submit-btn');
    const compressProgress = document.getElementById('compress-progress');
    const compressBar = document.getElementById('compress-bar');
    const compressText = document.getElementById('compress-text');
    const uploadProgress = document.getElementById('upload-progress');
    
    submitBtn.querySelector('.spinner-border').classList.remove('d-none');
    submitBtn.disabled = true;
    compressProgress.style.display = 'block';
    
    const compressedFiles = [];
    
    // B∆∞·ªõc 1: N√©n t·∫•t c·∫£ ·∫£nh
    for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (file.type.startsWith('image/')) {
            const compressed = await compressImage(file);
            compressedFiles.push({
                file: compressed,
                name: file.name.replace(/\.[^/.]+$/, '.jpg') // ƒê·ªïi extension th√†nh .jpg
            });
        }
        
        const percent = ((i + 1) / files.length) * 100;
        compressBar.style.width = percent + '%';
        compressText.textContent = `${i + 1}/${files.length}`;
    }
    
    // B∆∞·ªõc 2: Upload t·ª´ng batch nh·ªè (3 ·∫£nh/l·∫ßn ƒë·ªÉ tr√°nh timeout v·ªõi 60-70 ·∫£nh)
    compressProgress.style.display = 'none';
    uploadProgress.style.display = 'block';
    
    const batchSize = 3;  // Gi·∫£m t·ª´ 5 xu·ªëng 3 cho ·ªïn ƒë·ªãnh
    let uploaded = 0;
    
    for (let i = 0; i < compressedFiles.length; i += batchSize) {
        const batch = compressedFiles.slice(i, i + batchSize);
        try {
            const result = await uploadBatch(batch);
            uploaded += result.uploaded || batch.length;
        } catch (error) {
            console.error(`Batch ${Math.floor(i/batchSize) + 1} failed:`, error);
            // Ti·∫øp t·ª•c v·ªõi batch ti·∫øp theo thay v√¨ d·ª´ng ho√†n to√†n
        }
        
        const percent = (uploaded / compressedFiles.length) * 100;
        uploadProgress.querySelector('.progress-bar').style.width = percent + '%';
        document.getElementById('progress-text').textContent = `${uploaded}/${compressedFiles.length}`;
        
        // Th√™m delay nh·ªè gi·ªØa c√°c batch ƒë·ªÉ gi·∫£m t·∫£i server
        if (i + batchSize < compressedFiles.length) {
            await new Promise(resolve => setTimeout(resolve, 500)); // 0.5s delay
        }
    }
    
    // Submit form cu·ªëi c√πng kh√¥ng c√≥ ·∫£nh (ƒë√£ upload ri√™ng)
    const form = document.getElementById('activity-form');
    const imageInput = document.getElementById('images');
    imageInput.remove(); // X√≥a input file ƒë·ªÉ kh√¥ng upload l·∫°i
    form.submit();
}

// Upload 1 batch ·∫£nh v·ªõi retry logic
async function uploadBatch(compressedFiles, retryCount = 0) {
    const formData = new FormData();
    formData.append('csrf_token', document.querySelector('input[name="csrf_token"]').value);
    
    const activityId = window.currentActivityId; // S·∫Ω ƒë∆∞·ª£c set t·ª´ server
    if (!activityId) {
        console.error('No activity ID found');
        throw new Error('No activity ID');
    }
    
    compressedFiles.forEach((item, index) => {
        formData.append('batch_images', item.file, item.name);
    });
    formData.append('activity_id', activityId);
    
    try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 60000); // 60s timeout
        
        const response = await fetch('/activities/upload-batch', {
            method: 'POST',
            body: formData,
            signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('Batch uploaded successfully:', result);
        return result;
    } catch (error) {
        console.error('Upload batch error:', error);
        
        // Retry logic cho network errors (t·ªëi ƒëa 2 l·∫ßn)
        if (retryCount < 2 && (error.name === 'AbortError' || error.message.includes('fetch'))) {
            console.log(`Retrying batch upload (attempt ${retryCount + 1}/2)...`);
            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s
            return uploadBatch(compressedFiles, retryCount + 1);
        }
        
        throw error;
    }
}

// Set activity ID t·ª´ server (n·∫øu c√≥ temp_activity_id trong session)
{% if session.get('temp_activity_id') %}
window.currentActivityId = {{ session.get('temp_activity_id') }};
console.log('Activity ID loaded:', window.currentActivityId);
{% endif %}
</script>
{% endblock %}
